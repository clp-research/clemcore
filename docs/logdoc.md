# Keeping Records of Interactions

Every episode produces its own records of the interaction, which is saved as
```interactions.json``` in the episode folder inside the ```<gamename>/records```
directory.

The game master should log every action that is necessary to score the game,
generate the dialogue transcripts and other relevant information for 
posterior inspection of the interaction.

This is taken care of by the ```GameRecorder``` class, which has methods to log
various types of information.

- ```log_event```: must be called to log every action; see details below.
- ```log_next_turn```: must be called at the beginning of every game turn; 
what a turn means is a decision of the game designer.
- ```log_players```: must be called once, in the game setup, to
log the description of the agents playing each role in the game.
- ```log_key```: can be optionally used to log game-specific keys and values.
- ```log_turn_score```: should be called in the scoring method to log turn-level scores.
- ```log_episode_score```: should be called in the scoring method to log episode-level scores.


## Logging Players

The GameMaster ```setup``` method must call ```log_player``` passing a dictionary
that maps player identifier strings to a description of the player 
(e.g. is it a pretrained model, a human, or a program).

Use ```GM``` for the GameMaster and ```Player i```, where i is an integer, for
the other players. These identifiers for players are also used in the 
```interaction``` dictionaries.

## Logging Interaction

An interaction is a list of lists, in choronological order, of the actions made by the
game master. Such actions should be logged by the GameMaster using the 
```log_event``` method which also logs the timestamp. 

An event can be only an action or an action and a corresponding API call 
(in which case they are both identifiable by the shared timestamp).

```log_event``` requires a ```from``` and a ```to``` value (both are Player
identifiers, see above.) It also require an action dictionary that must contain
at least the two following keys:

- ```type```: the action type (see basic types below)
- ```content```: a string with the action message.

The basic action types are:

- ```send message```: an utterance that is sent from GM to a player (its content is only the last utterance, not the whole dialogue context)
- ```get messsage```: an utterance generated by a player
- ```metadata```: any relevant information the GameMaster logs (not visible to players, but that should be in the transcript)
- ```parse```: a manipulation of a response string, when needed (e.g. to extract a grid from a response)
- ```error```: an error message emited by the GameMaster
- ```invalid format```: an invalid answer that causes the game to be aborted

If a game needs more custom actions, they should be documented in the game directory.

Use ```from: "GM"``` and ```to: "GM"``` for messages that the Game Master emits to itself (not the players).


Here is an example of what the ```interactions.json``` file of an episode will
look like:

```json
{
  "some_other_key_1": "some_other_value",
  "some_other_key_2": "some_other_value",
  "players": {
    "GM": "Game Master for privateshared",
    "Player 1": "gpt-3.5",
    "Player 2": "human"
  },
  "turns": [
    [
      {
        "timestamp": "timestamp_1",
        "from": "GM",
        "to": "Player 1",
        "action": {
          "type": "send message",
          "content": "this is a message from GM to Player 1."
        }
      },
      {
        "timestamp": "timestamp",
        "from": "Player 1",
        "to": "GM",
        "action": {
          "type": "get message",
          "content": "this is a message from GM to Player 1."
        }
      },
      {
        "timestamp": "timestamp",
        "from": "GM",
        "to": "GM",
        "action": {
          "type": "parse",
          "content": "this is a parsed response from Player 1 to GM.",
          "other_key": "other_value"
        }
      }
    ],
    [
      {
        "timestamp": "timestamp",
        "from": "GM",
        "to": "GM",
        "action": {
          "type": "metadata",
          "content": "metadata not visible to players but added to transcript"
        }
      },
      {
        "timestamp": "timestamp_2",
        "from": "GM",
        "to": "Player 2",
        "action": {
          "type": "send message",
          "content": "this is a message from GM to Player 2."
        }
      },
      {
        "timestamp": "timestamp",
        "from": "Player 2",
        "to": "GM",
        "action": {
          "type": "get message",
          "content": "this is a message Player 2 to GM."
        }
      }
    ]
  ]
}
```

## Logging Calls

We also want to log the exact input and output from an API, because sometimes 
the GameMaster's prompt needs to be manipulated differently for each type of API.

The API call returns the manipulated prompt and the raw response, that should
just simple be logged by the GameMaster without further interference.

For that, use the optional ```call``` argument in ```log_event``` to log the
call with the same timestamp and an action.

The calls will be stored in a ```requests.json``` that containts the raw inputs and outputs of calls made to APIs.

Here is an example of how the requests file of an episode will look like:

```json
[
    {
        "timestamp": "timestamp_1",
        "manipulated_prompt_obj": "the whole prompt object passed to the API call",
        "raw_response_obj": "the whole response object received from the API call"
    },
    {
        "timestamp": "timestamp_2",
        "manipulated_prompt_obj": "the whole prompt object passed to the API call",
        "raw_response_obj": "the whole response object received from the API call"
    }
]
```

## Logging Scores

The game master computes the scores by evaluating the episodes' interaction records.

Games can have multiple turn-level scores and episode-level scores. 

Use ```log_turn_score``` to log a score name and its value for a given turn index
and ```log_episode_score``` to log a score name and its value for the whole
episode. Episode scores are usually measures of game success.

The score results will be stored to ```scores.json``` which contains:
- ```turn scores```: the turn-level scores for each game turn.
- ```episode scores```: the episode-level scores for the episode.

You can log as many scores as you wish. The minimal requirements is to log the episode-level scores defined in ```clemgame/metrics.py``` (see the paper's appendix for details).

**Important**: if the game was aborted, all episode-level scores should be ```np.nan``` and turn-level scores can be logged up to the turn when the game was aborted. If the game was won or lost, all metrics should be a numerical value. This is specially revelant for the main score of each game, so that the evaluation script correctly distinguishes %played and computes the main score only for actually played games.  

Here is an example of how the ```scores.json``` file of an episode will look like:

```json
{
    "turn scores": {
        "1": {"accuracy": 0.8, "f1": 0.7},
        "2": {"accuracy": 0.5, "f1": 0.8},
        "3": {"accuracy": 0.4, "f1": 0.9}
    },
    "episode scores": {
        "accuracy": 0.8,
        "f1": 0.7
    }
}
```
